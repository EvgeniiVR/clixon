/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****
 * Autocli mode support
 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <stdarg.h>
#include <time.h>
#include <ctype.h>

#include <unistd.h>
#include <dirent.h>
#include <syslog.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/param.h>
#include <sys/mount.h>
#include <pwd.h>
#include <assert.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clixon/clixon.h>

#include "clixon_cli_api.h"
#include "cli_common.h"

/*
 * CLIXON CLI parse-tree workpoint API: Essentially a mirror of the cligen_wp_set() and similar functions
 */
static char *
co2apipath(cg_obj *co)
{
    struct cg_callback *cb;
    cvec               *cvv;
    cg_var             *cv;
    
    if (co == NULL)
	return NULL;
    if ((cb = co->co_callbacks) == NULL)
	return NULL;
    if ((cvv = cb->cc_cvec) == NULL)
	return NULL;
    if ((cv = cvec_i(cvv, 0)) == NULL)
	return NULL;
    return cv_string_get(cv);;
}

static cvec*
cvec_append(cvec *cvv0,
	    cvec *cvv1)
{
    cvec   *cvv2 = NULL;
    cg_var *cv;
    
    if (cvv0 == NULL){
	if ((cvv2 = cvec_dup(cvv1)) == NULL){
	    clicon_err(OE_UNIX, errno, "cvec_dup");
	    return NULL;
	}
    }
    else{
	if ((cvv2 = cvec_dup(cvv0)) == NULL){
	    clicon_err(OE_UNIX, errno, "cvec_dup");
	    return NULL;
	}
	cv = NULL; 	/* Append cvv1 to cvv2 */
	while ((cv = cvec_each1(cvv1, cv)) != NULL)
	    cvec_append_var(cvv2, cv);
    }
    return cvv2;
}

/*! Enter a CLI edit mode
 * @param[in]  h    CLICON handle
 * @param[in]  cvv  Vector of variables from CLIgen command-line
 * @param[in]  argv Vector oif user-supplied keywords
 * Format of argv:
 *   <api_path_fmt> Generated API PATH (This is where we are in the tree)
 *   <treename>     Name of generated cligen parse-tree, eg "datamodel"
 *   <dbname>       "running"|"candidate"|"startup"y
 */
int
cli_auto_edit(clicon_handle h,
	      cvec         *cvv1,
	      cvec         *argv)
{
    int           retval = -1;
    char         *api_path_fmt;  /* xml key format */
    char         *api_path = NULL;
    cg_var       *cv;
    char         *treename;
    pt_head      *ph;  
    cg_obj       *co;
    cg_obj       *coorig;
    cligen_handle ch;
    cvec         *cvv2 = NULL; /* cvv2 = cvv0 + cvv1 */

    cv = cvec_i(argv, 1);
    treename = cv_string_get(cv);
    ch = cli_cligen(h);
    if ((ph = cligen_ph_find(cli_cligen(h), treename)) == NULL){
	clicon_err(OE_PLUGIN, 0, "No such parsetree header: %s", treename);
	goto done;
    }
    if ((co = cligen_co_match(ch)) != NULL &&
	(coorig = co->co_treeref_orig) != NULL)
	cligen_ph_workpoint_set(ph, coorig);
    else{
	clicon_err(OE_YANG, EINVAL, "No workpoint found");
	goto done;
    }
    if ((cvv2 = cvec_append(clicon_data_cvec_get(h, "cli-edit-cvv"), cvv1)) == NULL)
	goto done;
    fprintf(stderr, "%s alloc %p\n", __FUNCTION__, cvv2);
    /* First argv argument: API_path format */
    if ((api_path_fmt = co2apipath(coorig)) == NULL){
	clicon_err(OE_YANG, EINVAL, "No apipath found");
	goto done;
    }
    /* get api-path and xpath */
    if (api_path_fmt2api_path(api_path_fmt, cvv2, &api_path) < 0)
	goto done;
    /* Store this as edit-mode */
    clicon_data_set(h, "cli-edit-mode", api_path);
    if (clicon_data_cvec_set(h, "cli-edit-cvv", cvv2) < 0)
	goto done;
    retval = 0;
 done:
    if (api_path)
	free(api_path);
    return retval;
}

/*! CLI callback: Working point tree up to parent
 * @param[in]  h    CLICON handle
 * @param[in]  cvv  Vector of variables from CLIgen command-line
 * @param[in]  argv Vector oif user-supplied keywords
 * Format of argv:
 *   <treename>     Name of generated cligen parse-tree, eg "datamodel"
 *   <dbname>       "running"|"candidate"|"startup"
 */
int
cli_auto_up(clicon_handle h,
	    cvec         *cvv,
	    cvec         *argv)
{
    int      retval = -1;
    cg_var  *cv;
    char    *treename;
    cg_obj  *co0 = NULL; /* from */
    cg_obj  *co1 = NULL; /* to (parent, or several parent steps) */
    pt_head *ph;
    cvec    *cvv0 = NULL;
    cvec    *cvv1 = NULL; /* copy */
    char    *api_path_fmt0;  /* from */
    char    *api_path_fmt1;  /* to */
    char    *api_path = NULL;
    int      i;
    int      j;
    
    cv = cvec_i(argv, 0);
    treename = cv_string_get(cv);
    if ((ph = cligen_ph_find(cli_cligen(h), treename)) == NULL){
	clicon_err(OE_PLUGIN, 0, "No such parsetree header: %s", treename);
	goto done;
    }
    if ((co0 = cligen_ph_workpoint_get(ph)) == NULL)
	goto ok;
    co1 = co_up(co0);
    /* Find parent that has a callback */
    while (co1 && (co1->co_callbacks == NULL))
	co1 = co_up(co1);
    cligen_ph_workpoint_set(ph, co1);
    if (co1 == NULL){
	clicon_data_set(h, "cli-edit-mode", "");
	clicon_data_cvec_del(h, "cli-edit-cvv");
	goto ok;
    }
    /* get before and after api-path-fmt (as generated from yang) */
    api_path_fmt0 = co2apipath(co0);
    api_path_fmt1 = co2apipath(co1);
    assert(strlen(api_path_fmt0) > strlen(api_path_fmt1));
    /* Find diff of 0 and 1 (how many variables differ?) and trunc cvv0 by that amount */
    cvv0 = clicon_data_cvec_get(h, "cli-edit-cvv");
    j=0; /* count diffs */
    for (i=strlen(api_path_fmt1); i<strlen(api_path_fmt0); i++)
	if (api_path_fmt0[i] == '%')
	    j++;
    cvv1 = cvec_new(0);
    for (i=0; i<cvec_len(cvv0)-j; i++){
	cv = cvec_i(cvv0, i);
	cvec_append_var(cvv1, cv);	
    }
    /* get api-path and xpath */
    if (api_path_fmt2api_path(api_path_fmt1, cvv1, &api_path) < 0)
	goto done;
    /* Store this as edit-mode */
    clicon_data_set(h, "cli-edit-mode", api_path);
    clicon_data_cvec_set(h, "cli-edit-cvv", cvv1);
 ok:
    retval = 0;
 done:
    if (api_path)
	free(api_path);
    return retval;
}

/*! CLI callback: Working point tree reset to top level
 * @param[in]  h    CLICON handle
 * @param[in]  cvv  Vector of variables from CLIgen command-line
 * @param[in]  argv Vector oif user-supplied keywords
 * Format of argv:
 *   <treename>     Name of generated cligen parse-tree, eg "datamodel"
 *   <dbname>       "running"|"candidate"|"startup"
 */
int
cli_auto_top(clicon_handle h,
	     cvec         *cvv,
	     cvec         *argv)
{
    int      retval = -1;
    cg_var  *cv;
    char    *treename;
    pt_head *ph;
    cvec    *cvv0 = NULL;
    
    cv = cvec_i(argv, 0);
    treename = cv_string_get(cv);
    if ((ph = cligen_ph_find(cli_cligen(h), treename)) == NULL){
	clicon_err(OE_PLUGIN, 0, "No such parsetree header: %s", treename);
	goto done;
    }
    cligen_ph_workpoint_set(ph, NULL);
    /* Store this as edit-mode */
    clicon_data_set(h, "cli-edit-mode", "");
    if ((cvv0 = clicon_data_cvec_get(h, "cli-edit-cvv")) != NULL)
	clicon_data_del(h, "cli_edit-cvv");
    retval = 0;
 done:
    return retval;
}

/*! CLI callback: Working point tree show
 * @param[in]  h    CLICON handle
 * @param[in]  cvv  Vector of variables from CLIgen command-line
 * @param[in]  argv Vector oif user-supplied keywords
 * Format of argv:
 *   <treename>     Name of generated cligen parse-tree, eg "datamodel"
 *   <dbname>       "running"|"candidate"|"startup"
 *   <format>       "text"|"xml"|"json"|"cli"|"netconf" (see format_enum)
 *   <pretty>       true|false: pretty-print or not
 *   <state>        true|false: pretty-print or not
 *   <prefix>       to print before cli syntax output
 */
int
cli_auto_show(clicon_handle h,
	      cvec         *cvv,
	      cvec         *argv)
{
    int         retval = 1;
    char       *treename;
    char       *db;
    char       *api_path = NULL;
    char       *formatstr;
    enum format_enum format;
    enum genmodel_type gt;
    pt_head    *ph;
    char       *xpath = NULL;
    cxobj      *xp;
    cxobj      *xc = NULL;
    cvec       *nsc = NULL;
    yang_stmt  *yspec;
    cxobj      *xerr;
    cxobj      *xt = NULL;
    cxobj     **vec;
    size_t      veclen;
    int         i;
    int         isroot;
    int         pretty;
    char       *prefix = NULL;
    int         state;
    cg_var     *boolcv = NULL;
    
    if (cvec_len(argv) != 5 && cvec_len(argv) != 6){
	clicon_err(OE_PLUGIN, 0, "Usage: <treename> <database> <format> <pretty> <state> [<prefix>].");
	goto done;
    }
    /* First argv argument: treename */
    treename = cv_string_get(cvec_i(argv, 0));
    /* Second argv argument: Database */
    db = cv_string_get(cvec_i(argv, 1));
    /* Third format: output format */
    formatstr = cv_string_get(cvec_i(argv, 2));
    if ((int)(format = format_str2int(formatstr)) < 0){
	clicon_err(OE_PLUGIN, 0, "Not valid format: %s", formatstr);
	goto done;
    }
    /* Fourth: pretty-print */
    if ((boolcv = cv_new(CGV_BOOL)) == NULL){
	clicon_err(OE_UNIX, errno, "cv_new");
	goto done;
    }
    if (cv_parse(cv_string_get(cvec_i(argv, 3)), boolcv) < 0){
	clicon_err(OE_UNIX, errno, "Parse boolean %s", cv_string_get(cvec_i(argv, 3)));
	goto done;
    }
    pretty = cv_bool_get(boolcv);
    /* Fifth: state */
    if (cv_parse(cv_string_get(cvec_i(argv, 4)), boolcv) < 0){
	clicon_err(OE_UNIX, errno, "Parse boolean %s", cv_string_get(cvec_i(argv, 4)));
	goto done;
    }
    state = cv_bool_get(boolcv);

    /* Sixth: prefix */
    if (cvec_len(argv) == 6) {     
	prefix = cv_string_get(cvec_i(argv, 5));
    }
    if ((yspec = clicon_dbspec_yang(h)) == NULL){
	clicon_err(OE_FATAL, 0, "No DB_SPEC");
	goto done;
    }
    if ((ph = cligen_ph_find(cli_cligen(h), treename)) == NULL){ /* XXX not used */
	clicon_err(OE_PLUGIN, 0, "No such parsetree header: %s", treename);
	goto done;
    }
    /* Store this as edit-mode */
    if (clicon_data_get(h, "cli-edit-mode", &api_path) == 0 && strlen(api_path))
	;
    else
	api_path = "/";
    if (api_path2xpath(api_path, yspec, &xpath, &nsc, NULL) < 0)
	goto done;
    isroot = (xpath == NULL) || strcmp(xpath,"/")==0;
    if (state == 0){     /* Get configuration-only from database */
	if (clicon_rpc_get_config(h, NULL, db, xpath, nsc, &xt) < 0)
	    goto done;
    }
    else {               /* Get configuration and state from database */
	if (strcmp(db, "running") != 0){
	    clicon_err(OE_FATAL, 0, "Show state only for running database, not %s", db);
	    goto done;
	}
	if (clicon_rpc_get(h, xpath, nsc, CONTENT_ALL, -1, &xt) < 0)
	    goto done;
    }
    if ((xerr = xpath_first(xt, NULL, "/rpc-error")) != NULL){
	clixon_netconf_error(xerr, "Get configuration", NULL);
	goto done;
    }
    if (xpath_vec(xt, nsc, "%s", &vec, &veclen, xpath) < 0) 
	goto done;
    
    for (i=0; i<veclen; i++){
	xp = vec[i];
	/* Print configuration according to format */
	switch (format){
	case FORMAT_XML:
	    if (isroot)
		clicon_xml2file(stdout, xp, 0, pretty);
	    else{
		while ((xc = xml_child_each(xp, xc, CX_ELMNT)) != NULL)
		    clicon_xml2file(stdout, xc, 0, pretty);
	    }
	    fprintf(stdout, "\n");
	    break;
	case FORMAT_JSON:
	    if (isroot)
		xml2json_cb(stdout, xp, pretty, cligen_output);
	    else{
		while ((xc = xml_child_each(xp, xc, CX_ELMNT)) != NULL)
		    xml2json_cb(stdout, xc, pretty, cligen_output);
	    }
	    fprintf(stdout, "\n");
	    break;
	case FORMAT_TEXT:
	    if (isroot)
		xml2txt_cb(stdout, xp, cligen_output); /* tree-formed text */
	    else
		while ((xc = xml_child_each(xp, xc, CX_ELMNT)) != NULL)
		    xml2txt_cb(stdout, xc, cligen_output); /* tree-formed text */
	    break;
	case FORMAT_CLI:
	    if ((gt = clicon_cli_genmodel_type(h)) == GT_ERR)
		goto done;
	    if (isroot)
		xml2cli_cb(stdout, xp, prefix, gt, cligen_output); /* cli syntax */
	    else
		while ((xc = xml_child_each(xp, xc, CX_ELMNT)) != NULL)
		    xml2cli_cb(stdout, xc, prefix, gt, cligen_output); /* cli syntax */
	    break;
	case FORMAT_NETCONF:
	    fprintf(stdout, "<rpc xmlns=\"%s\"><edit-config><target><candidate/></target><config>",
		    NETCONF_BASE_NAMESPACE);
	    if (pretty)
		fprintf(stdout, "\n");
	    if (isroot)
		clicon_xml2file(stdout, xp, 2, pretty);
	    else
		while ((xc = xml_child_each(xp, xc, CX_ELMNT)) != NULL)
		    clicon_xml2file(stdout, xc, 2, pretty);
	    fprintf(stdout, "</config></edit-config></rpc>]]>]]>\n");
	    break;
	} /* switch */
    }
    retval = 0;
 done:
    if (boolcv)
	cv_free(boolcv);
    if (xt)
	xml_free(xt);
    if (nsc)
	xml_nsctx_free(nsc);
    if (vec)
	free(vec);
    if (xpath)
	free(xpath);
    return retval;
}

/*! CLI callback: set auto db item
 * @param[in]  h    Clicon handle
 * @param[in]  cvv  Vector of cli string and instantiated variables 
 * @param[in]  argv Vector. First element xml key format string, eg "/aaa/%s"
 * Format of argv:
 *   <api-path-fmt> Generated
 */
int 
cli_auto_set(clicon_handle h,
	     cvec         *cvv,
	     cvec         *argv)
{
    int   retval = -1;
    cvec *cvv2 = NULL;
    
    cvv2 = cvec_append(clicon_data_cvec_get(h, "cli-edit-cvv"), cvv);
    if (cli_dbxml(h, cvv2, argv, OP_REPLACE, NULL) < 0)
	goto done;
    retval = 0;
 done:
    if (cvv2)
	cvec_free(cvv2);
    return retval;
}

/*! Merge datastore xml entry
 * @param[in]  h    Clicon handle
 * @param[in]  cvv  Vector of cli string and instantiated variables 
 * @param[in]  argv Vector. First element xml key format string, eg "/aaa/%s"
 */
int 
cli_auto_merge(clicon_handle h,
	       cvec         *cvv,
	       cvec         *argv)
{
    int retval = -1;
    cvec *cvv2 = NULL;
    
    cvv2 = cvec_append(clicon_data_cvec_get(h, "cli-edit-cvv"), cvv);
    if (cli_dbxml(h, cvv2, argv, OP_MERGE, NULL) < 0)
	goto done;
    retval = 0;
 done:
    if (cvv2)
	cvec_free(cvv2);
    return retval;
}

/*! Create datastore xml entry
 * @param[in]  h    Clicon handle
 * @param[in]  cvv  Vector of cli string and instantiated variables 
 * @param[in]  argv Vector. First element xml key format string, eg "/aaa/%s"
 */
int 
cli_auto_create(clicon_handle h,
		cvec         *cvv,
		cvec         *argv)
{
    int retval = -1;
    cvec *cvv2 = NULL;
    
    cvv2 = cvec_append(clicon_data_cvec_get(h, "cli-edit-cvv"), cvv);
    if (cli_dbxml(h, cvv2, argv, OP_CREATE, NULL) < 0)
	goto done;
    retval = 0;
 done:
    if (cvv2)
	cvec_free(cvv2);
    return retval;
}

/*! Delete datastore xml
 * @param[in]  h    Clicon handle
 * @param[in]  cvv  Vector of cli string and instantiated variables 
 * @param[in]  argv Vector. First element xml key format string, eg "/aaa/%s"
 */
int 
cli_auto_del(clicon_handle h,
	     cvec         *cvv,
	     cvec         *argv)
{
    int   retval = -1;
    cvec *cvv2 = NULL;
    
    cvv2 = cvec_append(clicon_data_cvec_get(h, "cli-edit-cvv"), cvv);
    if (cli_dbxml(h, cvv2, argv, OP_REMOVE, NULL) < 0)
	goto done;
    retval = 0;
 done:
    if (cvv2)
	cvec_free(cvv2);
    return retval;
}
