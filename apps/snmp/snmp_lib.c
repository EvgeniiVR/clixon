/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2022 Olof Hagsand and Kristofer Hallin

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****
  * See RFC 6643
  * Extensions are grouped in some categories, the one I have seen are, example:
  * 1. leaf
  *      smiv2:max-access "read-write";
  *      smiv2:oid "1.3.6.1.4.1.8072.2.1.1";
  *      smiv2:defval "42"; (not always)
  * 2. container, list
  *      smiv2:oid "1.3.6.1.4.1.8072.2.1";	
  * 3. module level
  *      smiv2:alias "netSnmpExamples" {
  *        smiv2:oid "1.3.6.1.4.1.8072.2";
  *

 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <unistd.h>
#include <pwd.h>
#include <syslog.h>
#include <errno.h>
#include <signal.h>
#include <assert.h>
#include <sys/types.h>
#include <netinet/ether.h> /* ether_aton */

/* net-snmp */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clixon/clixon.h>

#include "snmp_lib.h"

/*
 * Local variables
 */
/* Mapping between yang keyword string <--> clixon constants 
 * Here is also the place where doc on some types store variables (cv)
 */
/* Mapping between smiv2 yang extension access string string <--> netsnmp handler codes (agent_handler.h) 
 * Here is also the place where doc on some types store variables (cv)
 * see netsnmp_handler_registration_create()
 */
static const map_str2int snmp_access_map[] = {
    {"read-only",             HANDLER_CAN_RONLY}, /* HANDLER_CAN_GETANDGETNEXT */
    {"read-write",            HANDLER_CAN_RWRITE}, /* HANDLER_CAN_GETANDGETNEXT | HANDLER_CAN_SET */
    {"not-accessible",        0}, // XXX
    {"accessible-for-notify", 0}, // XXX
    {NULL,                   -1}
};

/* Map between clixon and ASN.1 types. 
 * @see net-snmp/library/asn1.h
 * @see union netsnmp_vardata in net-snmp/types.h
 * XXX not complete
 * XXX TimeTicks
 */
static const map_str2int snmp_type_map[] = {
    {"int32",        ASN_INTEGER},   // 2
    {"string",       ASN_OCTET_STR}, // 4
    {"enumeration",  ASN_INTEGER},   // 2 special case
    {"uint32",       ASN_GAUGE},     // 0x42 / 66
    {"uint32",       ASN_COUNTER},   // 0x41 / 65
    {"uint32",       ASN_TIMETICKS}, // 0x43 / 67
    {"uint64",       ASN_COUNTER64}, // 0x46 / 70
    {"boolean",      ASN_INTEGER},   // 2 special case -> enumeration
    {NULL,           -1}
};
#define CLIXON_ASN_PHYS_ADDR 0x4242

/* Map between SNMP message / mode str and int form
 */
static const map_str2int snmp_msg_map[] = {
    {"MODE_SET_RESERVE1",    MODE_SET_RESERVE1}, // 0
    {"MODE_SET_RESERVE2",    MODE_SET_RESERVE2}, // 1
    {"MODE_SET_ACTION",      MODE_SET_ACTION},   // 2
    {"MODE_SET_COMMIT",      MODE_SET_COMMIT},   // 3
    {"MODE_SET_FREE",        MODE_SET_FREE},     // 4
    {"MODE_GET",             MODE_GET},          // 160
    {"MODE_GETNEXT",         MODE_GETNEXT},      // 161
    {NULL,                   -1}
};

/*! Translate from snmp string to int representation
 * @note Internal snmpd, maybe find something in netsnmpd?
 */
int
snmp_access_str2int(char *modes_str)
{
    return clicon_str2int(snmp_access_map, modes_str);
}

const char *
snmp_msg_int2str(int msg)
{
    return clicon_int2str(snmp_msg_map, msg);
}

/*! Free clixon snmp handler struct
 */
int
snmp_handle_free(clixon_snmp_handle *sh)
{
    if (sh->sh_cvk)
	cvec_free(sh->sh_cvk);
    free(sh);
    return 0;
}

/*! Translate from YANG to SNMP asn1.1 type ids (not value)
 *
 * @param[in]    ys         YANG leaf node
 * @param[out]   asn1_type  ASN.1 type id
 * @retval   0   OK
 * @retval   -1  Error
 * @see type_yang2snmp, yang only
 */
int
type_yang2asn1(yang_stmt    *ys,
	       int          *asn1_type)
{
    int        retval = -1;
    yang_stmt *yrestype;  /* resolved type */
    char      *restype;  /* resolved type */
    char      *origtype=NULL;   /* original type */
    int        at;
    yang_stmt *ypath;
    yang_stmt *yref;

    /* Get yang type of leaf and trasnslate to ASN.1 */
    if (yang_type_get(ys, &origtype, &yrestype, NULL, NULL, NULL, NULL, NULL) < 0)
	goto done;
    restype = yrestype?yang_argument_get(yrestype):NULL;
    /* Special case: leafref, find original type */
    if (strcmp(restype, "leafref")==0){
	if ((ypath = yang_find(yrestype, Y_PATH, NULL)) == NULL){
	    clicon_err(OE_YANG, 0, "No path in leafref");
	    goto done;
	}
	if (yang_path_arg(ys, yang_argument_get(ypath), &yref) < 0)
	    goto done;
	if (yang_type_get(yref, &origtype, &yrestype, NULL, NULL, NULL, NULL, NULL) < 0)
	    goto done;
	restype = yrestype?yang_argument_get(yrestype):NULL;
    }
    /* Special case: counter32, maps to same resolved type as gauge32 */
    if (strcmp(origtype, "counter32")==0){
	at = ASN_COUNTER;
    }
    else if (strcmp(origtype, "object-identifier-128")==0){
	at = ASN_OBJECT_ID;
    }
    else if (strcmp(origtype, "binary")==0){
	at = ASN_OCTET_STR;
    }
    else if (strcmp(origtype, "timeticks")==0){
	at = ASN_TIMETICKS; /* Clixon extended string type */
    }
    else if (strcmp(origtype, "phys-address")==0){
	at = CLIXON_ASN_PHYS_ADDR; /* Clixon extended string type */
    }

    /* translate to asn.1 */
    else if ((at = clicon_str2int(snmp_type_map, restype)) < 0){
	clicon_err(OE_YANG, 0, "No snmp translation for YANG %s type:%s",
		   yang_argument_get(ys), restype);
	goto done;
    }
    if (asn1_type)
	*asn1_type = at;
    retval = 0;
 done:
    return retval;
}

/*! Translate from yang/xml/clixon to SNMP/ASN.1
 *
 * @param[in]   snmpval  Malloc:ed snmp type
 * @param[in]   snmplen  Length of snmp type
 * @param[in]   reqinfo  snmpd API struct for error
 * @param[in]   requests snmpd API struct for error
 * @param[out]  valstr   Clixon/yang/xml string value, free after use)
 * @retval      1        OK, and valstr set
 * @retval      0        Invalid value or type
 * @retval      -1       Error
 * @see type_xml2snmpstr  for snmpget
 */
int
type_snmp2xml(yang_stmt                  *ys,
	      netsnmp_variable_list      *requestvb,
	      netsnmp_agent_request_info *reqinfo,
	      netsnmp_request_info       *requests,
	      char                      **valstr)
{
    int          retval = -1;
    char        *cvstr;
    enum cv_type cvtype;
    cg_var      *cv;
    yang_stmt   *yrestype;  /* resolved type */
    char        *restype;  /* resolved type */
    char        *origtype=NULL;   /* original type */

    clicon_debug(1, "%s", __FUNCTION__);
    if (valstr == NULL){
	clicon_err(OE_UNIX, EINVAL, "valstr is NULL");
	goto done;
    }
    cvstr = (char*)clicon_int2str(snmp_type_map, requestvb->type);
    /* Get yang type of leaf and trasnslate to ASN.1 */
    if (yang_type_get(ys, &origtype, &yrestype, NULL, NULL, NULL, NULL, NULL) < 0)
	goto done;
    restype = yrestype?yang_argument_get(yrestype):NULL;
    /* special case for enum */
    if (strcmp(cvstr, "int32")==0 && strcmp(restype, "enumeration") == 0)
	cvstr = "string";
    else if (strcmp(cvstr, "int32")==0 && strcmp(restype, "boolean") == 0)
	cvstr = "string";
    cvtype = cv_str2type(cvstr);
    if ((cv = cv_new(cvtype)) == NULL){
	clicon_err(OE_UNIX, errno, "cv_new");
	goto done; 
    }
    switch (requestvb->type){
    case ASN_TIMETICKS:   // 67
    case ASN_INTEGER:   // 2
	if (cvtype == CGV_STRING){ 	/* special case for enum */
	    char *xmlstr;
	    cbuf *cb = NULL;

	    if (strcmp(restype, "enumeration") == 0){
		if ((cb = cbuf_new()) == NULL){
		    clicon_err(OE_UNIX, errno, "cbuf_new");
		    goto done;
		}
		cprintf(cb, "%ld", *requestvb->val.integer);
		if (yang_valstr2enum(yrestype, cbuf_get(cb), &xmlstr) < 0)
		    goto done;
		cbuf_free(cb);
	    }
	    else if (strcmp(restype, "boolean") == 0){
		if (*requestvb->val.integer == 1)
		    xmlstr = "true";
		else
		    xmlstr = "false";
	    }
	    cv_string_set(cv, xmlstr);
	}
	else
	    cv_int32_set(cv, *requestvb->val.integer);
	break;
    case ASN_GAUGE:     // 0x42
	cv_uint32_set(cv, *requestvb->val.integer);
	break;
    case ASN_OCTET_STR: // 4
	cv_string_set(cv, (char*)requestvb->val.string);
	break;
    case ASN_COUNTER64:{ // 0x46 / 70
	uint64_t u64;
	struct counter64 *c64;
	c64 = requestvb->val.counter64;
	u64 = c64->low;
	u64 += c64->high*0x100000000;
	cv_uint64_set(cv, u64);
	break;
    }
    default:
	assert(0); // XXX
	clicon_debug(1, "%s %s not supported", __FUNCTION__, cv_type2str(cvtype));
	netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
	goto fail;
	break;
    }
      
    if ((*valstr = cv2str_dup(cv)) == NULL){
	clicon_err(OE_UNIX, errno, "cv2str_dup");
	goto done;
    }
    retval = 1;
 done:
    clicon_debug(1, "%s %d", __FUNCTION__, retval);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Given xml value and YANG,m return corresponding malloced snmp string
 * There is a special case for enumeration which is integer in snmp, string in YANG
 * @param[in]  xmlstr
 * @retval     1     OK
 * @retval     0     Invalid type
 * @retval     -1    Error
 * @see type_snmp2xml  for snmpset
 */
int
type_xml2snmpstr(char      *xmlstr,
		 yang_stmt *ys,
		 char      **snmpstr)

{
    int        retval = -1;
    yang_stmt *yrestype;  /* resolved type */
    char      *restype;  /* resolved type */
    char      *origtype=NULL;   /* original type */
    char      *str = NULL;
    int        ret;

    if (snmpstr == NULL){
	clicon_err(OE_UNIX, EINVAL, "snmpstr");
	goto done;
    }
    /* Get yang type of leaf and trasnslate to ASN.1 */
    if (yang_type_get(ys, &origtype, &yrestype, NULL, NULL, NULL, NULL, NULL) < 0)
	goto done;
    restype = yrestype?yang_argument_get(yrestype):NULL;
    if (strcmp(restype, "enumeration") == 0){ 	/* special case for enum */
	if ((ret = yang_enum2valstr(yrestype, xmlstr, &str)) < 0)
	    goto done;
	if (ret == 0){
	    clicon_debug(1, "Invalid enum valstr %s", xmlstr);
	    goto fail;
	}
    }
    /* special case for bool: although smidump translates TruthValue to boolean
     * and there is an ASN_BOOLEAN constant:
     * 1) there is no code for ASN_BOOLEAN and
     * 2) Truthvalue actually translates to enum true(1)/false(0)
     */
    else if (strcmp(restype, "boolean") == 0){ 	
	if (strcmp(xmlstr, "false")==0)
	    str = "0";
	else
	    str = "1";
    }
    else{
	str = xmlstr;
    }
    if ((*snmpstr = strdup(str)) == NULL){
	clicon_err(OE_UNIX, errno, "strdup");
	goto done;
    }
    retval = 1;
 done:
    clicon_debug(2, "%s %d", __FUNCTION__, retval);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Given snmp string value (as translated frm XML) parse into snmp value
 *
 * @param[in]     snmpstr  SNMP type string
 * @param[in,out] asn1type ASN.1 type id
 * @param[out]    snmpval  Malloc:ed snmp type
 * @param[out]    snmplen  Length of snmp type
 * @param[out]    reason   Error reason if retval is 0
 * @retval        1        OK
 * @retval        0        Invalid
 * @retval       -1        Error
 * @note asn1type can be rewritten from CLIXON_ASN_ to ASN_
 * XXX See  sprint_realloc_timeticks
 */
int
type_snmpstr2val(char       *snmpstr,
		 int        *asn1type,
		 u_char    **snmpval,
		 size_t     *snmplen,
		 char      **reason)
{
    int   retval = -1;
    int   ret;

    if (snmpval == NULL || snmplen == NULL){
	clicon_err(OE_UNIX, EINVAL, "snmpval or snmplen is NULL");
	goto done;
    }
    switch (*asn1type){
    case ASN_INTEGER:   // 2
	*snmplen = 4;
	if ((*snmpval = malloc(*snmplen)) == NULL){
	    clicon_err(OE_UNIX, errno, "malloc");
	    goto done;
	}
	if ((ret = parse_int32(snmpstr, (int32_t*)*snmpval, reason)) < 0)
	    goto done;
	if (ret == 0)
	    goto fail;
	break;
    case ASN_TIMETICKS:
    case ASN_COUNTER: // 0x41
    case ASN_GAUGE:   // 0x42
	*snmplen = 4;
	if ((*snmpval = malloc(*snmplen)) == NULL){
	    clicon_err(OE_UNIX, errno, "malloc");
	    goto done;
	}
	if ((ret = parse_uint32(snmpstr, (uint32_t*)*snmpval, reason)) < 0)
	    goto done;
	if (ret == 0)
	    goto fail;

	break;
    case ASN_OBJECT_ID:{ // 6
	oid    oid1[MAX_OID_LEN] = {0,};
	size_t sz1 = MAX_OID_LEN;
	if (snmp_parse_oid(snmpstr, oid1, &sz1) == NULL){
	    clicon_debug(1, "Failed to parse OID %s", snmpstr);
	    goto fail;
	}
	*snmplen = sizeof(oid)*sz1;
	if ((*snmpval = malloc(*snmplen)) == NULL){
	    clicon_err(OE_UNIX, errno, "malloc");
	    goto done;
	}
	memcpy(*snmpval, oid1, *snmplen);
	break;
    }
    case ASN_OCTET_STR: // 4
	*snmplen = strlen(snmpstr)+1;
	if ((*snmpval = (u_char*)strdup((snmpstr))) == NULL){
	    clicon_err(OE_UNIX, errno, "strdup");
	    goto done;
	}
	break;
    case ASN_COUNTER64:{ // 0x46 / 70
	uint64_t u64;
	struct counter64 *c64;
	*snmplen = sizeof(struct counter64); // 16!
	if ((*snmpval = malloc(*snmplen)) == NULL){
	    clicon_err(OE_UNIX, errno, "malloc");
	    goto done;
	}
	memset(*snmpval, 0, *snmplen);
	if ((ret = parse_uint64(snmpstr, &u64, reason)) < 0)
	    goto done;
	c64 = (struct counter64 *)*snmpval;
	c64->low = u64&0xffffffff;
	c64->high = u64/0x100000000;
	if (ret == 0)
	    goto fail;
    }
	break;
    case CLIXON_ASN_PHYS_ADDR:{
	struct ether_addr *eaddr;
	*snmplen = sizeof(*eaddr);
	if ((*snmpval = malloc(*snmplen + 1)) == NULL){
	    clicon_err(OE_UNIX, errno, "malloc");
	    goto done;
	}
	memset(*snmpval, 0, *snmplen + 1);
	if ((eaddr = ether_aton(snmpstr)) == NULL){
	    clicon_debug(1, "ether_aton(%s)", snmpstr);
	    goto fail;
	}
	memcpy(*snmpval, eaddr, sizeof(*eaddr));
	*asn1type = ASN_OCTET_STR;
	break;
    }
    default:
	assert(0);
    }
    retval = 1;
 done:
    clicon_debug(2, "%s %d", __FUNCTION__, retval);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Construct an xpath from yang statement, internal fn using cb
 * Recursively construct it to the top.
 * @param[in]  ys      Yang statement
 * @param[in]  keyvec  Array of [name,val]s as a cvec of key name and values
 * @param[out] cb      xpath as cbuf
 * @retval     0       OK
 * @retval    -1       Error
 * @see yang2xpath
 */ 
static int
yang2xpath_cb(yang_stmt *ys, 
	      cvec      *keyvec,
	      cbuf      *cb)
{
    yang_stmt *yp; /* parent */
    int        i;
    cvec      *cvk = NULL; /* vector of index keys */
    int        retval = -1;
    char      *prefix = NULL;
    
    if ((yp = yang_parent_get(ys)) == NULL){
	clicon_err(OE_YANG, EINVAL, "yang expected parent %s", yang_argument_get(ys));
	goto done;
    }
    if (yp != NULL && /* XXX rm */
	yang_keyword_get(yp) != Y_MODULE && 
	yang_keyword_get(yp) != Y_SUBMODULE){
	if (yang2xpath_cb(yp, keyvec, cb) < 0) /* recursive call */
	    goto done;
	if (yang_keyword_get(yp) != Y_CHOICE && yang_keyword_get(yp) != Y_CASE){
	    cprintf(cb, "/");
	}
    }
    prefix = yang_find_myprefix(ys);
    if (yang_keyword_get(ys) != Y_CHOICE && yang_keyword_get(ys) != Y_CASE){
	if (prefix)
	    cprintf(cb, "%s:", prefix);
	cprintf(cb, "%s", yang_argument_get(ys));
    }
    switch (yang_keyword_get(ys)){
    case Y_LIST:
	cvk = yang_cvec_get(ys); /* Use Y_LIST cache, see ys_populate_list() */
	/* Iterate over individual keys  */
	assert(keyvec && cvec_len(cvk) == cvec_len(keyvec));
	for (i=0; i<cvec_len(cvk); i++){
	    cprintf(cb, "[");
	    if (prefix)
		cprintf(cb, "%s:", prefix);
	    cprintf(cb, "%s='%s']",
		    cv_string_get(cvec_i(cvk, i)),
		    cv_string_get(cvec_i(keyvec, i)));
	}
	break;
    case Y_LEAF_LIST:
	assert(0); // NYI
	break;
    default:
	break;
    } /* switch */
    retval = 0;
 done:
    return retval;
}

/*! Construct an xpath from yang statement
 * Recursively construct it to the top.
 * @param[in]  ys    Yang statement
 * @param[in]  keyvec  Array of [name,val]s as a cvec of key name and values
 * @param[out] xpath Malloced xpath string, use free() after use
 * @retval     0     OK
 * @retval     -1    Error
 * @note
 * 1. This should really be in a core .c file, like clixon_yang, BUT
 * 2. It is far from complete so maybe keep it here as a special case
 */ 
int
yang2xpath(yang_stmt *ys,
	   cvec      *keyvec,
	   char     **xpath)
{
    int   retval = -1;
    cbuf *cb = NULL;

    if ((cb = cbuf_new()) == NULL){
	clicon_err(OE_UNIX, errno, "cbuf_new");
	goto done;
    }
    if (yang2xpath_cb(ys, keyvec, cb) < 0)
	goto done;
    if (xpath && (*xpath = strdup(cbuf_get(cb))) == NULL){
	clicon_err(OE_UNIX, errno, "strdup");
	goto done;
    }
    retval = 0;
 done:
    if (cb)
	cbuf_free(cb);
    return retval;
}

#ifdef NOTUSED
/*!
 * @param[in]  ys    Yang statement
 * @param[out] xpath Malloced xpath string, use free() after use
 * @retval     0     OK
 * @retval     -1    Error
 */
int
clixon_table_create(netsnmp_table_data_set *table0,
		    yang_stmt              *ys,
		    clicon_handle           h)
{
    int                 retval = -1;
    cvec               *nsc = NULL;
    cxobj              *xt = NULL;
    cxobj              *xerr;
    char               *xpath;
    cxobj              *xtable;
    cxobj              *xe;
    cxobj              *xleaf;
    char               *valstr;
    netsnmp_table_data *table;
    netsnmp_table_row  *row;
    netsnmp_table_row  *tmprow;
    int                 i;
    int                 ret;
    cvec               *keyvec = NULL;

    if (table0 == NULL || (table = table0->table) == NULL){
	clicon_err(OE_UNIX, EINVAL, "table0 /->table is NULL");
	goto done;
    }
    if (xml_nsctx_yang(ys, &nsc) < 0)
        goto done;

    if (yang2xpath(ys, keyvec, &xpath) < 0)
        goto done;

    if (clicon_rpc_get(h, xpath, nsc, CONTENT_ALL, -1, &xt) < 0)
        goto done;

    if ((xerr = xpath_first(xt, NULL, "/rpc-error")) != NULL){
        clixon_netconf_error(xerr, "clicon_rpc_get", NULL);
        goto done;
    }

#if 1
    /* Boils down to snmp_varlist_add_variable */
    if (snmp_varlist_add_variable(&table->indexes_template,
				  NULL,
				  0,
				  ASN_OCTET_STR,
				  NULL,
				  0) == NULL){
	clicon_err(OE_XML, errno, "snmp_varlist_add_variable");
	goto done;
    }
    if ((ret = netsnmp_table_set_add_default_row(table0,  2, ASN_OCTET_STR, 1, NULL, 0)) != SNMPERR_SUCCESS){
	clicon_err(OE_SNMP, ret, "netsnmp_table_set_add_default_row");
	goto done;
    }
    if ((ret = netsnmp_table_set_add_default_row(table0,  3, ASN_OCTET_STR, 1, NULL, 0)) != SNMPERR_SUCCESS){
	clicon_err(OE_SNMP, ret, "netsnmp_table_set_add_default_row");
	goto done;
    }
#else
    netsnmp_table_dataset_add_index(table, ASN_OCTET_STR);
    netsnmp_table_set_multi_add_default_row(table0, 2, ASN_OCTET_STR, 1, NULL, 0, 3, ASN_OCTET_STR, 1, NULL, 0, 0);
#endif
    if ((xtable = xpath_first(xt, nsc, "%s", xpath)) != NULL) {
        for (tmprow = table->first_row; tmprow; tmprow = tmprow->next)
            netsnmp_table_dataset_remove_and_delete_row(table0, tmprow);

        xe = NULL; /* Loop thru entries in table */
        while ((xe = xml_child_each(xtable, xe, CX_ELMNT)) != NULL) {
            if ((row = netsnmp_create_table_data_row()) == NULL){
		clicon_err(OE_UNIX, errno, "netsnmp_create_table_data_row");
		goto done;
	    }
            xleaf = NULL; /* Loop thru leafs in entry */
            i = 1; /* tableindex start at 1 */
            while ((xleaf = xml_child_each(xe, xleaf, CX_ELMNT)) != NULL) {
                valstr = xml_body(xleaf);
                if (i == 1){ // Assume first entry is key XXX should check YANG
#if 1
		    if ((snmp_varlist_add_variable(&row->indexes, NULL, 0, ASN_OCTET_STR, (const u_char *)valstr, strlen(valstr))) == NULL){
			clicon_err(OE_XML, errno, "snmp_varlist_add_variable");
			goto done;
		    }
#else
                    netsnmp_table_row_add_index(row, ASN_OCTET_STR, valstr, strlen(valstr));
#endif
		}
                else{
                    if ((ret = netsnmp_set_row_column(row, i, ASN_OCTET_STR, valstr, strlen(valstr))) != SNMPERR_SUCCESS){
			clicon_err(OE_SNMP, ret, "netsnmp_set_row_column");
			goto done;
		    }
                    if ((ret = netsnmp_mark_row_column_writable(row, i, 1)) != SNMPERR_SUCCESS){
			clicon_err(OE_SNMP, ret, "netsnmp_set_row_column");
			goto done;
		    }
                }
                i++;
            }

            netsnmp_table_dataset_add_row(table0, row);
        }
    }

    retval = 0;

done:
    if (xt)
        xml_free(xt);
    if (nsc)
        xml_nsctx_free(nsc);
    return retval;
}
#endif
